
#if 1

/*
主线程和子线程之间的协作：
设置主线程等待，设置子线程和主线程分离，访问共享数据时加锁，条件变量等等。

主要着重讲一下子线程和主线程之间的任务结果传递：
当子线程需要向主线程返回计算结果时，std::future（未来）和std::promise（承诺）是更优雅的方式：
主线程通过std::future“等待” 子线程的结果；
子线程通过std::promise“设置” 结果，结果就绪后自动唤醒主线程
*/

#include <iostream>
#include <thread>
#include <future>  // 包含future和promise

// 子线程任务：计算平方，通过promise返回结果
void calculate_square(int x, std::promise<int>&& prom) {
    int result = x * x;
    prom.set_value(result);  // 设置结果，通知future
}

int main() {
    std::promise<int> prom;       // 子线程用于设置结果
    std::future<int> fut = prom.get_future();  // 主线程用于获取结果

    // 启动子线程，传递promise（注意用move转移所有权）
    std::thread t(calculate_square, 5, std::move(prom));

    // 主线程等待结果（阻塞，直到子线程调用set_value）
    int result = fut.get();  // get()只能调用一次
    std::cout << "5的平方是：" << result << "\n";  // 输出25

    t.join();
    return 0;
}


#endif


/*
malloc出来的指针，用delete进行释放会怎么样：
1.程序崩溃（Crash）
delete会读取内存块头部的“元数据”（如 new 分配时记录的对象大小、类型信息等），但 malloc() 
分配的内存块元数据格式不同（或根本没有这些元数据），可能导致 delete 访问非法地址，触发崩溃
（如 segmentation fault）。

2.内存泄漏或资源损坏
若 malloc() 分配的内存用于存储自定义类型对象（且手动调用了构造函数），delete 可能无法正确
识别对象类型，导致析构函数调用失败，造成对象内部资源（如成员变量指向的动态内存）泄漏。
反之，若内存块未存储对象（仅作为原始数据），delete 对 “不存在的析构函数” 的调用可能直
接破坏内存结构。

*/

/*
一个程序在linux系统上一直运行，内存越来越大是为什么？当达到系统最大容量时会发生什么？
内存越来越大主要是因为发生了内存泄漏，内存达到最大容量之后，如果在使用new或malloc开辟空间就会
返回bad_alloc或者是返回Null。当系统内存(物理内存+swap分区)全部被耗尽则会触发OOM机制。OOM会强制杀死
进程，所以可能会导致程序崩溃。

*/

/*
如果malloc创建的内存指针，改变了这个指针的指向会怎么样？
1.改变了指针的指向之后，会导致原来分配的内存块无法进行释放，会造成内存泄漏
2.如果使用free释放了改变了指向的指针，可能会导致未定义的行为发生，可能发生崩溃或者是堆损坏，
因为如果指针指向了其他malloc开辟空间，会导致该部分的内存空间重复释放，如果指针指向了无效地址，就会造成
操作野指针的问题

*/

/*
什么是悬空指针？
悬空指针是指指针指向的内存已失效，但是指针本身未被处理。指针指向的内存被释放，但是指针未被置空

野指针和悬空指针的区别：
野指针是未被初始化，或者初始化为随机地址的指针，一开始内存地址就无效。悬空指针是之前指向的内存有效
，有效内存被释放后，指针未被处理。

使用野指针的问题：
1.导致程序崩溃：
访问已释放的内存或者访问未分配的内存，原理是通过野指针去访问内存的时候，该物理内存可能对于野指针是无权限访问或者
是没有映射的物理内存，操作系统会终止进行访问
2.数据会被篡改：
野指针指向的内存如果是系统分配给其他的变量或者是数据结构的话，对于野指针的操作会修改这些数据
3.内存泄漏：
如果指针是指向一块动态分配的内存，当该指针变成野指针之后，该动态内存将无法释放，造成内存泄漏

*/

/*
什么是大端序列和小端序列，怎么判断？
大端序列是指：高位字节存放在低地址，地位字节存放在高地址
小端序列是指：低位字节存放在低地址，高位字节存放在高地址

#include <iostream>
using namespace std;

// 定义联合体：4字节整数和1字节数组共享内存
union EndianTest {
    uint32_t num;    // 4字节整数（如 0x12345678）
    uint8_t bytes[4];// 1字节数组（用于读取每个地址的字节）
};

int main() {
    EndianTest et;
    et.num = 0x12345678;  // 给4字节整数赋值

    // 读取低地址（bytes[0] 对应地址 0x100）的字节
    if (et.bytes[0] == 0x78) {  // 低地址是低位字节 0x78 → 小端
        cout << "当前系统是小端序列（Little-Endian）" << endl;
    } else if (et.bytes[0] == 0x12) {  // 低地址是高位字节 0x12 → 大端
        cout << "当前系统是大端序列（Big-Endian）" << endl;
    } else {
        cout << "未知字节序" << endl;
    }
    return 0;
}
*/

/*
懒分配和写时复制有什么优缺点，怎么优化？
优点：
1.减少初始资源的浪费，对于没有使用到的资源不实际分配。
2.加快初始化的速度，因为只需要记录资源的需求而不需要实际分配，显著减少启动和创建的时间

缺点：
可能会产生大量的缺页中断，会导致频繁的用户态和内核态之间的切换，以及物理内存分配的开销。
解决方案：
1.对于一些大概率会被修改的数据可以提前复制，避免后续缺页中断，比如对于循环内如果要频繁修改的话
可以提前将数据进行复制
2.批量处理：将多次零散的写操作合并成一次批量修改，减少缺页中断的次数
3.写时复制比较适合用于读多写少的场景，如果对于写比较多的场景，可以直接采用普通的复制
*/

/*
EPOLL ET模式怎么保证缓冲区数据读完：
1.收到可读事件之后，采用循环读取的方式将事件读完，循环读取直到返回-1，且错误码为EAGAIN
2.ET模式必须配合非阻塞套接字使用，因为如果使用阻塞的套接字，当数据被读完之后就会阻塞等待新数据
到来，导致无法处理其他事件

EPOLL ET模式怎么保证缓冲区数据全部写完：
1.收到可写事件后，采用循环写入的方式进行写事件，同时需要采用非阻塞的套接字，避免内核缓冲区
满了之后不会阻塞，而是返回-1，并且设置错误码为EAGAIN
2.当内核缓冲区满了之后，但是数据还没有发完，就需要手动保持EPOLLOUT事件处于注册状态，
这是因为ET模式下套接字有事件只会被通知一次，所以每次没有发送完都需要重新向EPOLL注册。
当数据发送完之后移除套接字的EPOLLOUT事件，具体是通过待发送数据大小和已发送数据大小进行比较

EPOLL LT模式怎么保证数据被全部读完：
LT模式下会比较简单，因为如果套接字有事件的话会一直通知，会从epoll_wait醒过来，所以循环读取直到
返回0或者-1表示数据被读完了

EPOLL LT模式下怎么保证数据被全部写完：
LT模式下数据未发送完不需要向EPOLL注册EPOLLOUT事件，因为当有套接字有EPOLLOUT事件到来时会自动唤醒

*/


/*
为什么浮点数之间不能直接用==来判断是否相等？
原因是二进制无法准确的存储浮点数，只能以一种近似的方式存储。
比如0.1+0.2,因为0.1和0.2都是以近似的方式存储的，所以两者的和也是近似，0.3本身也是近似存储
所以0.1+0.2不能直接==0.3，而是应该两者做差，然后判断差值如果能够小于一点的阈值时就能判断两者是
相等的

*/

/*
lambda表达式变量的捕获方式？
lambda的作用允许在代码中方便的定义临时的函数对象
1.值捕获：会创建一个外部变量的副本，并且值捕获默认是const，所以不能直接进行修改，如果要进行修改
需要加上mutable
2.引用捕获：直接引用外部变量，可以进行值修改
3.如果捕获this指针，即捕获当前类成员函数所属对象，但是如果类对象的生命周期和Lambda生命周期不一致可能会导致
悬空引用的问题
*/

/*
可重入锁和不可重入锁：
1.不可重入锁：当一个线程已经获取锁，如果再获取同一把锁会阻塞，导致死锁,因为不可重入锁只记录锁是否被
获取，不记录获取锁的线程和获取次数。例如std::mutex
2.可重入锁：当一个线程获取锁之后还可以继续获取同一把锁，因为记录了获取锁的线程和获取次数，
只有当最后一次释放，锁才会被真正的释放。例如std::recursive_mutex
*/

/*
详解一下websocket:
websocket是一种在单个tcp连接上实现全双工通信的网络协议，允许客户端和服务端之间建立永久的连接，
并且服务端和客户端都可以给对方发送消息，适用于实时聊天和实时游戏等场景

连接建立：
客户端正常通过发送http请求建立连接，服务端发送的响应中将协议升级为websocket协议，服务端发送的
响应被确认后，http协议就升级成为了websocket协议，并且只有在握手阶段需要传输http头部，后续数据
传输的阶段都不需要传输http头部

*/

/*
websocket的长连接和http的长连接有什么区别：
1.从HTTP1.1开始，支持HTTP长连接，客户端发送给服务端的报文中connection:keep-alive，一个长连接
可以处理多个http请求，实际上是优化了短连接的复用。但始终遵循请求-响应的顺序。并且这个长连接是有超时时间的，
超时无请求则关闭这个长连接
2.websocket的长连接无超时时间，长期保持，并且不需要遵循请求-响应这样的顺序，客户端和服务端可以同时
发送数据
*/

/*
Cmake常用命令：
核心组织思想：是通过在最外层CMakeLists中设置版本，名称以及可执行文件和库文件的输出路径，然后再
采用add_subdirectory来去处理指定的子目录中的CMakeLists,在最内内层中去生成可执行文件

1.cmake_minimum_required，指定cmake最低版本要求
cmake_minimum_required(VERSION 3.10)  # 要求 CMake 版本不低于 3.10

2.Project指定项目名称
project(MyProject VERSION 1.0 LANGUAGES CXX)  # C++ 项目，版本 1.0

3.创建可执行目标文件
add_executable(myapp src/main.cpp src/utils.cpp)  # 生成 myapp 可执行文件

4.创建库
# 静态库（默认，后缀 .a 或 .lib）
add_library(mylib STATIC src/lib.cpp)
# 动态库（后缀 .so 或 .dll）
add_library(mylib SHARED src/lib.cpp)

5.为目标链接库
target_link_libraries(myapp PRIVATE mylib pthread)  # myapp 链接 mylib 和 pthread 库

6.递归搜索源文件
file(GLOB SRCS src/*.cpp)  # 匹配 src/ 下的所有 .cpp 文件

7.设置头文件搜索路径
include_directories(${PROJECT_SOURCE_DIR}/src/include)
include_directories(${PROJECT_SOURCE_DIR}/example)

8.设置库文件搜索路径
link_directories(${PROJECT_SOURCE_DIR}/lib)

9.add_subdirectory
add_subdirectory(src)
add_subdirectory(example)
告诉cmake去处理指定目录中的CMakeLists文件

10.设置项目可执行文件输出的路径和设置项目库文件输出的路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
*/

/*
编译阶段和运行阶段主要负责的内容以及判断错误是发生在编译阶段还是运行阶段：
编译阶段主要的工作：
1.语法检查：验证代码是否符合c++语法规则
2.语义检查：检查代码的逻辑合理性（如变量是否声明后使用、函数调用参数是否匹配、类型转换是否合法等）。

运行阶段主要的工作：
1.加载程序到内存：操作系统将可执行文件从磁盘加载到内存的代码段、数据段等区域。
2.初始化资源：分配内存（如全局变量、动态内存new）、打开文件、建立网络连接等。
3.执行代码逻辑：按照程序流程执行指令（如循环、分支、函数调用等），处理输入输出。
4.释放资源：程序结束前释放动态内存、关闭文件等。

根据编译和运行主要做的事情可知，编译阶段出现的错误主要是语法和语义错误以及链接时的错误，而运行阶段出现的错误
可以有内存访问错误，逻辑错误，资源错误等等
*/


/*
指针使用的问题：

#include <iostream>
using namespace std;

class Person{
public:
    void sayHi(){
        printf("Hi!\n");
    }
    void selfIntroduction(){
       printf("My name is %s\n",name.c_str());
    }
private:
    string name;
};

int main(){
    //这里将0x12345强转为Person*的指针，意味着让指针指向内存地址0x12345，因为这里调用的sayHi方法中没有访问
    //任何的成员变量，所以不需要通过this指针去读取对象数据，所以这里的执行是没有问题的，但是这样是不安全的
    ((Person*)0x12345)->sayHi();

    //这里将指针指向空，当调用selfIntroduction方法时，因为要访问成员变量，所以需要通过this指针去访问，这里
    //的this指针为NULL,程序会访问NULL地址的name成员变量，会触发内存访问错误
    ((Person*)NULL)->selfIntroduction();
    return 0;
}
*/

/*
STL容器中的拷贝都是实现的深拷贝，即复制了容器内所有元素的完整内容，新容器与原容器有完全独立的内存空间，两者互不
影响。并且同时还实现了移动构造函数，用于处理资源转移的场景，如果源对象为右值，则容器会窃取元对象的底层资源而非
复制。之所以实现移动构造函数是为了有时候避免深拷贝的开销，提高容器在传递和转换场景下的效率

vector在扩容时的机制是先开辟一块更大的内存空间，然后将原先的数据拷贝过来，这里拷贝会优先调用移动构造函数而不是拷贝
构造函数，在扩容逻辑中通过std::move将元素转换为右值，从而触发移动构造函数
*/


/*
MVCC版本并发控制的核心思想：
每一行数据存在多个版本，事务对数据的修改会生成新版本，而旧版本保留一段时间。读操作根据事务的可见性规则，
选择合适的版本读取，从而实现并发控制。即版本链+ReadView可见性规则

版本链：
InnoDB存储引擎下每行数据都有两个隐藏列，分别为修改该行数据的事务id和回滚指针。
当事务修改数据时，旧版本数据被写入 undo 日志，通过回滚指针（DB_ROLL_PTR）与当前版本关联，形成版本链。
不同事务对同一行的修改会产生多个 undo 日志，构成链式结构

可见性规则：
Read View（读视图）是事务在读取数据时生成的可见性判断依据，用于确定当前事务能看到哪个版本的数据
当事务去访问记录时，通过记录里面的id来和ReadView中的各个id号的范围进行对比，确定这个记录的创建时机以及对于当前
事务的可见性，从而找到可见性的版本
*/

/*
c++多线程编程详解：
https://zhuanlan.zhihu.com/p/613630658

网络编程详解：
https://blog.csdn.net/weixin_43484713/article/details/147905384

*/

/*
lock_guard和unique_lock都不能被复制，但是unique_lock可以被移动，分析一下原因：
首先两种锁都不能被复制的原因是：假如锁的实例已经持有了mutex互斥量，如果支持复制的话，另外一个锁的实例对象也会
持有这个互斥锁，这样会造成加锁的死锁以及重复释放的问题，所有两种锁都显示的将拷贝构造函数和赋值构造函数都delete了，
但是为什么unique_lock能够被移动而lock_guard不行，这是因为lock_guar的设计简单，直接将加锁和解锁与声明周期进行强
绑定，必须在当前作用域内完成锁的释放，不能将锁的所有权转移到其他作用域，但是unique_lock的
设计比较复杂，支持手动解锁，没有与声明周期进行强绑定，所以支持移动

*/

/*
shared_ptr是线程安全的吗？
1.shared_ptr的引用技术的操作是线程安全的，多个线程对于智能指针复制或者销毁时，其内部的引用技术是原子性的，所以是
安全的。
2.shared_ptr不保证管理的对象资源是线程安全的，多线程通过智能指针去修改对象资源时需要手动保证线程安全
3.多线程直接修改shared_ptr本身不是线程安全的
// 危险：多个线程操作同一个 shared_ptr 实例
std::shared_ptr<int> ptr = std::make_shared<int>(0);

// 线程 1
ptr = std::make_shared<int>(1);  // 修改 ptr 本身

// 线程 2
ptr = std::make_shared<int>(2);  // 与线程 1 产生数据竞争
*/

/*
volatile无法保证原子性：这是因为volatile只能保证每次读取变量都是从内存中去读取最新值，但是无法阻止多线程的操作
例如int a=0,同时两个线程执行a++。a++实际上包含三个步骤，首先从内存中将a的值加载到寄存器，然后对寄存器中的值+1，
最后将寄存器中的值写入内存，多线程时可能两个线程都读取a+0,任何都+1写入内存，最后内存值还是为1，但实际上应该为2
*/

/*
如果磁盘的读取速度变成GB/s，能取代内存吗？
不能取代内存，内存存在的意义不仅仅是读取速度块，而且内存可以支持随机访问，延迟很低。而磁盘只能顺序读取，因此
磁盘随机访问的延迟很高。内存通过地址总线和数据总线和cpu直接交互，cpu可以根据内存地址读取数据，磁盘无法和cpu
直接交互
*/

/*
详解resize和reserve：
resize(n):改变容器的实际数量，若原数量小于n，采用默认构造添加元素，若原数量大于n，采用析构函数销毁元素。
reserve(n):预先分配空间，但是不创建元素。并且仅当n>capacity时才会分配新内存，不改变容器的size，注意
如果reserve的空间比capacity小的时候，容器不会进行任何操作。
如果容器中放的是自定义类型的数据时，resize时会调用默认构造函数或者是拷贝构造函数和移动构造函数。
*/

/*
reserve如果分配更大空间时，会将原来旧内存中的数据通过拷贝构造拷贝到新内存中，而不是采用移动构造，而
vector在扩容的时候，可以采用移动构造将数据从旧内存中移动到新内存中。
这是因为reserve的时候如果采用移动构造会将旧内存中数据的资源转移到新内存中，而旧内存中的数据此时处于
有效但未定义的状态，因为已经不管理内存资源了，但是旧内存中的数据却不会马上被销毁，而是要等着旧内存被
释放的时候调用析构函数进行销毁。所以旧内存中的数据此时还有被使用的可能，就会出错。
而vectro采用移动构造之后，旧内存中的数据马上就被销毁了，所以不会被使用到，所以是安全的。

*/

/*
编译阶段和运行阶段的一些主要行为：
（一）明确属于编译阶段的行为
1.语法与语义检查
  编译器会检查代码是否符合 C++ 语法规则（如括号是否匹配、关键字是否正确）。
检查语义合法性（如变量未定义就使用、类型不匹配的赋值）。
例：int a = "hello"; 会在编译时报错（类型不匹配），属于编译阶段检查。
2.预处理相关操作
  所有预处理指令（#include、#define、条件编译等）的处理（见前文预处理阶段讲解）。
例：#define PI 3.14 会在编译预处理阶段将代码中所有 PI 替换为 3.14，运行时不存在 PI 这个标识符。
3.变量与函数的声明和定义（语法层面）
  编译器会记录变量的类型、作用域，函数的参数列表、返回值等信息（用于后续类型检查）。
例：int x; 的声明由编译器在编译时处理，确定 x 的内存布局（占 4 字节），但 x 的具体值在运行时才会被赋值。
4.函数重载决议
  编译器在编译时根据实参类型选择匹配的重载函数（见前文讲解）。
例：print(5) 和 print(3.14) 会在编译时分别绑定到 print(int) 和 print(double)，运行时直接调用对应函数。
5.模板实例化
  模板本身不是可执行代码，编译器在编译时会根据实际使用的类型生成具体的模板实例（如 vector<int>、vector<double> 是两个不同的实例）。
例：template<typename T> T add(T a, T b) { return a + b; } 在编译时会为 add(1, 2) 生成 int add(int, int) 的代码。
6.常量表达式计算（constexpr）
  用 constexpr 声明的常量或函数，若其值可在编译时确定，会由编译器直接计算结果并嵌入代码。
例：constexpr int x = 3 + 4; 编译时就会计算出 x = 7，运行时无需再计算。
7.虚函数表（vtable）的生成
  编译器会为包含虚函数的类生成虚函数表（存储虚函数地址），并在对象中插入虚表指针（vptr），这一过程在编译时完成。
例：基类 Base 和派生类 Derived 的虚函数表在编译时生成，运行时通过 vptr 查找具体函数。

（二）明确属于运行阶段的行为
1.变量的赋值与修改
  变量的具体值只有在程序运行时才会被设置或修改，编译器仅负责分配内存空间。
例：int x; x = 5; 中，x 的内存由编译器分配（编译时），但 x = 5 的赋值操作在运行时执行。
2.函数的实际执行
  函数调用指令由编译器生成（编译时），但函数体内的代码（如循环、计算）在运行时由 CPU 执行。
例：int sum(int a, int b) { return a + b; } 中，sum(2, 3) 的调用指令在编译时生成，但 a + b 的计算在运行时执行。
3.动态内存分配与释放
  new/delete 或 malloc/free 操作在运行时向操作系统申请或释放内存，编译器仅检查语法合法性。
例：int* p = new int[10]; 中，内存分配在运行时执行，若内存不足会抛出异常（运行时现象）。
4.用户输入与输出
  依赖外部输入（如 cin、文件读取）或输出（如 cout、文件写入）的操作，必须在运行时与外部设备交互。
例：cin >> x; 会在程序运行时等待用户输入，编译时无法预知输入值。
5.动态类型识别（RTTI）
  dynamic_cast 和 typeid 用于运行时确定对象的实际类型（依赖虚函数表）。
例：Base* obj = new Derived(); dynamic_cast<Derived*>(obj) 在运行时检查 obj 是否指向 Derived 类型。
6.异常的抛出与捕获
  异常的触发（如 throw）和处理（如 try/catch）在运行时执行，编译器仅确保异常机制的语法正确性。
例：throw "error"; 会在运行时检测到异常并跳转到对应的 catch 块。
7.多线程并发执行
  线程的创建（std::thread）和调度由操作系统在运行时管理，编译器仅生成线程创建的指令。
例：std::thread t(func); 在运行时创建新线程，编译时无法确定线程的执行顺序。
*/


/*
三个概念对比：重载，重写，重定义（隐藏）
重载:两个函数作用域相同，函数名相同，(参数数量 | 参数类型 | 参数顺序 不同都属于重载)，注意返回值类型不能作为重载
的依据，这是因为编译器在调用时无法确定调用哪个，并且很多时候的使用不需要返回值，这个时候如果返回值类型不同也能作为
重载的话，则在调用的时候也无法分辨出来调用哪个

重写：
1.继承关系
2.函数签名完全相同：函数名必须相同，参数列表必须相同，返回值类型需要兼容
3.基类函数必须为虚函数，基类函数为虚函数才能实现多态，基类函数如果不为虚函数，这时重写派生类的函数会隐藏
基类的同名函数，即调用时只能根据指针/引用编译器的实际类型进行函数调用，而无法进行多态调用
4.访问权限可以不同，派生类重写函数的访问权限可以和基类函数的访问权限不同
总结：
重写：基类virtual+派生类同签名->支持多态调用
隐藏：基类无virtual+派生类同名函数→不支持多态（编译时绑定），基类函数被“覆盖”但未被“重写”
virtual 关键字是区分两者的核心，它告诉编译器：“这个函数可能在派生类中被重写，需要支持多态调用”。

重定义(隐藏)：两个函数分别位于基类和子类，函数名相同，两个基类和子类的同名函数不构成重写就是重定义
*/

/*
为什么基类中虚函数的访问权限和派生类中的虚函数的访问权限不同，还是可以实现多态的调用？
因为访问权限是编译期进行检查，但是多态调用的函数匹配是运行时期检查
1.编译期：编译器只检查通过基类指针/引用调用的函数在基类中的访问权限是否允许（例如基类中是 public，则允许调用）。
2.运行时：实际执行派生类的重写函数，此时不再检查派生类中的访问权限（因为编译期已通过基类权限验证）

*/

/*
类中的虚函数可以声明为私有函数吗？
类中的虚函数可以声明为私有函数，但是一旦声明为私有函数，则外部类和派生类都不能访问了，但是
其子类还是可以正常的重写父类的虚函数，因为虚函数的重写只跟函数名有关，跟访问权限无关。实现多态
的基本原理都是存在的，并且虽然虚函数是私有的，其仍然存在于虚函数表中，并且子类重写虚函数也会将
虚函数表中的函数指针替换为子类重写的虚函数的函数指针，但是通过父类指针指向子类对象时并不能实现
多态调用，这是因为c++语法上禁止了调用私有函数，但是实际上从技术层面来说是可以通过虚表指针寻找
到私有的虚函数并且强行完成调用的
*/

/*
const int和int函数参数类型能构成重载吗？const int&和int&,const int*和int*能不能构成重载？
能不能构成重载主要是要看你这两个参数所能接收的类型是不是一致的，如果是一致的就不构成重载，不一致就构成重载。
const int和int的值类型都是int，所以是没有区别的，不能构成重载。
const int&和int&所能接收的类型不同，int&只能接收非const引用的类型,const int&能接收const变量，非const变量和字面量
能够构成重载，const int*和int*同理
*/

/*
map迭代器失效？
map的迭代器实际上是指向红黑树节点的指针，不同节点之间通过指针连接，而不是连续的内存，所以大部分的操作不会使得
迭代器失效。
1.删除当前迭代器指向的元素,通过erase，当前迭代器会失效，但是erase会返回下一个有效的迭代器
2.删除其他迭代器，当前迭代器有效
3.插入新节点，其他的迭代器都有效，因为红黑树进行平衡调整时并不会影响当前迭代器

*/

/*
static修饰的全局变量和普通全局变量有什么区别：
static修饰的全局变量和普通全局变量都属于全局区，全局区存储全局变量和静态变量。
static修饰的全局变量只能在当前源文件中使用，但是全局变量可以在所有源文件中使用，可以通过extern关键字
进行调用
*/

/*
初始化列表初始化和构造函数内部赋值的区别：
1.初始化列表初始化是直接在成员变量构造时进行初始化，而构造函数内部赋值是先构造成员变量，再进行赋值操作。
初始化列表更符合创建即初始化的语义，构造函数内部属于赋值操作
2.对于const修饰的成员变量以及引用的成员变量只能通过初始化列表进行初始化，因为不支持重新赋值修改
*/

/*
32位和64位数据类型所占大小之间有什么区别？
主要差异集中在指针类型和long数据类型，32位系统中指针和long类型占4个字节，64位系统中占8个字节

int和unsigned int之间的区别：
两者所占的内存大小是相同的，都是四字节，不同的是对于位的使用，因为unsigned int是无符号的，所以32位
全部用来表示数值，而int是有符号的，最高位用来表示符号位，(0表示整数，1表示负数)

*/


/*
ip地址、端口号、mac地址各自的作用分别是什么？
端口号：确定数据发给哪个应用程序
ip地址：确认数据发给哪个网络设备
mac地址：确认数据发给局域网内哪个硬件接口

ip地址是逻辑地址，可以重复分配，并且同一ip地址在不同局域网内可以重复，所以这种灵活性决定了ip地址无法
绑定硬件设备，只能在标识设备在当前网络中的逻辑身份
交换机的工作原理依赖于mac地址：交换机收到电信号，将电信号转换为数字信号，并且拿到数据层层封装成的
以太网帧，交换机中有mac地址表，其中的mac地址对应的有端口号，通过查询以太网帧的mac地址确定将数据
转发到哪个端口。需要注意的是如果源设备和目的设备处于同一个局域网内的话，经过交换机将数据转发到
该端口所连接的目的设备，而不会传输给下一个交换机或者是路由器。如果源设备和目的设备不在同一个
局域网内的时候，交换机会将数据传输给路由器

*/

/*
虽说实时视频和通话主要是UDP协议，但是实际上现在也有很多采用的是TCP协议，这是怎么做到的？
TCP协议的主要由于其重传机制和拥塞控制导致延迟，但是基于TCP协议栈的优化，快速重传和快速恢复以及
TCP fast open都能一定程度上减少延迟

1.关键数据用tcp进行传输，实时流用udp进行传输
2.应用层主动丢弃过期数据，避免tcp卡顿。通过给tcp传输的音视频数据加上时间戳，通过时间戳来判断数据
是否过期，过期主动丢弃，避免重传带来的时延
3.动态调整数据发送的粒度，缩小发送的数据包的大小

*/

/*
内存对齐的一个延伸：
如果多个线程访问同一个cache line中的不同变量，会造成cpu cache的缓存失效，导致伪共享的问题，所以这个时候
也可以使用内存对齐的思想，设置这两个不同的变量cache line内存对齐，分别处于一个单独的cache line中，这样
可以避免伪共享的问题

*/

/*
ping的原理：
ping 是一个基于 ICMP 协议的网络诊断工具，用于测试主机之间的连通性。它的工作原理涉及网络协议栈的多个层次。
客户端：
应用层(ping程序) → ICMP包(类型8) → IP包(协议=1) → 以太网帧(MAC地址)
服务端：
以太网帧 → IP包 → ICMP包(类型0) → 回送数据 → 封装发送

ping成功只能说明网络层可达，icmp协议正常工作
*/

/*
自平衡二叉树和红黑树效率对比：
这两种树的时间复杂度是一样的，都是logn，但是还是有一些细微差别：
AVL：查找速度通常略快，因为树更 “矮”，平均比较次数少
红黑树：插入 / 删除操作更快，因为旋转次数少，内存访问更连贯
所以红黑树在插入和删除上的效率会比avl树更加的优秀，由于工程的实际使用可能是会包含插入、删除和查找的各种情况
所以综合考虑下还是使用红黑树
*/



