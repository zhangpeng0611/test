#include <iostream>
#include <vector>
#include <algorithm>

/*

学习网址：https://blog.csdn.net/qq_52324409/article/details/121048486

序列式容器：
array,string,vector,list,forward_list,deque

关联式容器:
红黑树结构：map,multimap,set,multiset
哈希结构：unordered_map,unordered_set

容器适配器：
stack,queue,priority_queue

------------------------------------------------------------

前向迭代器（forward iterator）
假设p是一个前向迭代器了，则p支持p++，++p，*p 操作，还可以被复制和赋值，
可以用和！= 运算符进行比较，此外，两个正向迭代器还可以互相赋值。

双向迭代器（bidirectional iterator）
双向迭代器具有正向迭代器的全部功能，同时，双向迭代器还在正向迭代器的基础上进行–p，p–操作。

随机访问迭代器（random access iterator）
随机访问迭代器具有双向迭代器的全部功能，除此之外，假设 p 是一个随机访问迭代器，
i 是一个整型变量，则 p 还支持以下操作

p += i；使 p 向后移动 i 个位置
p -= i；使 p 往前移动 i 个位置
p + i；返回 p 后面第 i 个元素的迭代器
p – i；返回 p 前面第 i 个元素的迭代器
p [i]；返回 p 后面第 i 个元素的引用
​ 此外，两个随机访问迭代器 p1、p2 还可以用 <、>、<=、>= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。

迭代器失效:
list容器(序列式容器):当插入数据时，所有迭代器都不失效，当删除数据时，有且只有被删除节点的迭代器失效,
因为List节点的内存是离散存储的，删除和增加一个节点不会影响其他节点。好在可以接收erase函数返回的迭代器
erase方法可以返回下一个有效的迭代器


vector容器（序列式容器）：当插入数据时，如果capacity不发生变化时，插入数据节点之后的迭代器失效，如果capacity
发生变化，则所有的迭代器都失效。当删除数据时，被删除节点之后的迭代器都失效。因为vector容器的内存是
连续的，对一个元素进行操作会导致后续的所有元素进行移动。

关于deque容器迭代器失效的问题：
deque是由一个表来和一段一段连续的内存空间来进行存储数据的，表中存储了每一段连续内存的起始地址。
插入操作：
1、在队前或队后插入元素时（push_back(),push_front()）,由于可能缓冲区的空间不够，需要增加map中控器，
而中控器的个数也不够，所以新开辟更大的空间来容纳中控器，所以可能会使迭代器失效；但指针、引用仍有效。
***需要注意的是，为什么这里迭代器失效了，而指针和引用还有效，这是因为当插入元素导致中控器空间不足时，需要
* 重新分配一块更大的内存空间，并将原来中控器中的内容复制过去，而deque迭代器的结构实际上应该包括指向中控器中的
* 某个元素以及数据节点内的偏移量如下所示。
* // 迭代器可能的内部结构
struct Iterator {
    Controller* ctrl_ptr;  // 指向中控器中的某个元素（如ptr2）
    size_t offset;         // 数据节点内的偏移（如1 → 指向D）
};
当中控器重新分配时，指向中控器中某个元素的指针就会失效，所以迭代器也会失效，而指针和引用直接指向数据中的节点元素
，所以并不会失效。因为这里迭代器中有cur,first,end,node指针，node指针指向map中控器
当扩容中导致中控器重新分配时，迭代器中的中控器指针就会失效，但是原有元素所在的缓冲区不会移动。
因此，指向元素的指针/引用仍然指向有效内存。

2、在队列其他位置插入元素时，由于会造成缓冲区的一些元素的移动（源码中执行copy()来移动数据），
所以肯定会造成迭代器的失效；并且指针、引用都会失效。

删除操作：
1、删除队头或队尾的元素时，由于只是对当前的元素进行操作，所以其他元素的迭代器不会受到影响，
所以一定不会失效，而且指针和引用也都不会失效；

2、删除其他位置的元素时，也会造成元素的移动，所以其他元素的迭代器、指针和引用都会失效。



array:空间大小固定，不能增加或减少该容器的大小，只能访问和替换该容器的数据
 array 容器中包含了 at () 这样的成员函数，使得操作元素时比普通数组更安全。
 如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，
 就能避免这种开销。因此，当程序员确定没有越界产生时，使用[]，不确定时使用 at。

vector：空间大小可变，当原空间大小不足时，会以二倍开辟一块新的内存空间，再将原空间中的数据
复制或者移到新的内存空间，之后再将原来的内存空间释放掉，当扩容的时候会导致原来的迭代器失效。
vector可以通过resize来变化内部元素的数量，但是容量不变。

完全释放vector数组的内存：
1.使用swap函数，用一个临时vector对象和vector进行交换,vector<int>().swap(v);
本质是使用临时对象的生命周期和vector的内存管理机制，swap会交换vector内部的数据，包括指向内存的指针以及
size和capacity
2.采用shrink_to_fit将内存收缩到指定大小
3.将vector重新用一个空的数组进行赋值，v=vector<int>();v的原内存会被释放并且分配新的空内存

关于vector的扩容，在不同的平台下扩容的大小还不太一样，在MSVC下是以两倍的大小进行扩容的，但是在GCC下是以
1.5倍进行扩容的，以两倍扩容的话，空间比较大，可以减少扩容的次数，但是内存的空间利用率低。以1.5倍扩容的话，
内存利用率比较高，但是可能会导致多次扩容


emplace_back和push_back的区别，push_back会先将这个元素创建出来，然后再拷贝或者移动到数组末尾，如果
是拷贝的话还会将原来创建的元素销毁掉，而emplace_back则会直接在数组末尾创建出这个元素。


判断容器为空最好使用empty而不是使用size===0
性能优势：
对于list这样的容器，如果内部没有维护size的话，size() 可能需要遍历整个容器来计算元素数量，
时间复杂度为 O(n)，导致性能显著下降。
而使用empty是通过判断begin()==end(),这样的判断效率会更高


比较AVL树和红黑树：
AVL树：是严格的自平衡二叉树，其核心是左右子树的高度差的绝对值不超过一，当插入新节点后可能会导致
二叉树失衡。根据插入新节点的位置分为LL,RR,LR,RL这四种。分别对应不同的调整方式
1.LL失衡：在根节点的左子树的左子树插入新节点失衡，采用右旋
2.RR失衡：采用左旋
3.LR失衡：采用先左旋变成LL状态，然后再右旋。
4.RL失衡：采用先右旋变成RR状态，然后再左旋。
插入和删除节点时可能需要多次旋转来维持这种严格平衡
每个节点需要存储平衡因子，通常用一个四字节的整数进行存储，存储开销比较大


红黑树：是一种近似平衡的二叉树，保证最长路径长度<=2*最短路径长度
红黑树有以下五种特性：
1.根节点必须为黑色
2.叶子节点必须为黑色
3.红色节点的两个子节点必须为黑色
4.新插入的节点必须为红色
5.从任意节点到叶子节点的路径中，黑色节点数量相同

当插入新节点之后，可能会出现失衡的状态，需要通过变色和旋转来调整平衡，从新节点向上回溯，若
父节点为黑色则无冲突，父节点为红色则会有冲突，此时根据叔叔节点的情况来进行调整。
1.叔叔节点为红色，通过变色进行解决。
2.叔叔节点为黑色，通过旋转加变色进行解决。
插入删除通常只需要2-3次旋转就能保持平衡特性
每个节点只需要存储节点颜色，可以通过一个比特位进行标志


*/

int main()
{

    // vector容器怎么进行缩容
    // 1.通过swap进行缩容

    std::vector<int> vec;
    std::cout << vec.size() << std::endl;
    std::cout << vec.capacity() << std::endl;

    for (int i = 0; i < 10; ++i)
    {
        vec.push_back(i);
    }

    /*{
        std::vector<int> tmp;
        tmp.swap(vec);
        std::cout << tmp.size() << std::endl;
        std::cout << tmp.capacity() << std::endl;
    }
    std::cout << vec.size() << std::endl;
    std::cout << vec.capacity() << std::endl;*/

    // 使用shrink_to_fit将capacity设置为size大小
    vec.shrink_to_fit();
    std::cout << vec.size() << std::endl;
    std::cout << vec.capacity() << std::endl;

    return 0;
}